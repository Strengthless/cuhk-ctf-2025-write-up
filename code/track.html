<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Track Viewer</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
        background: #fff;
      }
      #hud {
        position: fixed;
        top: 8px;
        left: 8px;
        background: rgba(255, 255, 255, 0.8);
        padding: 6px 8px;
        border-radius: 6px;
        font-family: monospace;
      }
    </style>
  </head>
  <body>
    <div id="hud">
      Use mouse wheel or pinch to zoom. Drag to pan. [X] flipX [Y] flipY [ [ ]
      rotate ±90 [O] reverse order [+/-] spacing
    </div>
    <canvas id="cv"></canvas>
    <script>
      (async function () {
        const res = await fetch("/index-CZHshYmU.js");
        const js = await res.text();

        function extractJSONAfter(label) {
          const idx = js.indexOf(label);
          if (idx < 0) throw new Error("Label not found: " + label);
          let i = idx + label.length;
          while (i < js.length && /\s/.test(js[i])) i++;
          const q = js[i++];
          let esc = false,
            s = "";
          for (; i < js.length; i++) {
            const c = js[i];
            if (esc) {
              s += c;
              esc = false;
              continue;
            }
            if (c === "\\") {
              esc = true;
              continue;
            }
            if (c === q) break;
            s += c;
          }
          return JSON.parse(s);
        }

        const iArr = extractJSONAfter("i: JSON.parse(");
        const sArr = extractJSONAfter("s: JSON.parse(");
        const hKey = "h: [";
        const hPairsStart = js.indexOf(hKey);
        if (hPairsStart < 0) throw new Error("h array not found");
        const arrStart = js.indexOf("[", hPairsStart);
        let depth = 0,
          hEnd = -1;
        for (let k = arrStart; k < js.length; k++) {
          const ch = js[k];
          if (ch === "[") depth++;
          else if (ch === "]") {
            depth--;
            if (depth === 0) {
              hEnd = k;
              break;
            }
          }
        }
        if (hEnd < 0) throw new Error("h array bracket mismatch");
        const hRaw = js.slice(arrStart, hEnd + 1);
        const hArr = (0, eval)("(" + hRaw + ")");
        const mapping = new Map(hArr);

        // Geometry helpers
        function lerp(t, a, b) {
          return a + t * (b - a);
        }
        function dist(x, y) {
          return Math.hypot(x, y);
        }

        class Vec {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }
          add(v) {
            return new Vec(this.x + v.x, this.y + v.y);
          }
        }

        class Line {
          constructor(m, p1) {
            this.m = m;
            this.p1 = p1;
          }
          points() {
            return [this.m, this.p1];
          }
        }

        class Quad {
          constructor(m, p1, p2) {
            this.m = m;
            this.p1 = p1;
            this.p2 = p2;
          }
          points() {
            return [this.m, this.p1, this.p2];
          }
        }

        // Provider logic (adapted from bundle but without animation)
        function resolve(sym) {
          let v = mapping.get(sym);
          return sym === v ? v : resolve(v);
        }

        let idx = 0;
        let startPt = undefined;
        let curPt = undefined;

        function nextSegment() {
          const t = iArr[idx];
          const e = sArr.slice(4 * t[1], 4 * (t[1] + 1));
          let seg;
          switch (resolve(t[0])) {
            case "🚦":
            case "🚗": {
              if (!startPt) startPt = new Vec(e[0], e[1]);
              curPt = new Vec(e[0], e[1]);
              idx = (idx + 1) % iArr.length;
              return nextSegment();
            }
            case "↔️": {
              if (!curPt) throw new Error("No current point for line");
              const p = new Vec(e[0], e[1]).add(curPt);
              seg = new Line(curPt, p);
              curPt = p;
              break;
            }
            case "♾️": {
              if (!curPt) throw new Error("No current point for quad");
              const c1 = new Vec(e[0], e[1]).add(curPt);
              const p2 = new Vec(e[2], e[3]).add(curPt);
              seg = new Quad(curPt, c1, p2);
              curPt = p2;
              break;
            }
            case "⏱️": {
              if (!curPt || !startPt) throw new Error("Bad lap");
              seg = new Line(curPt, startPt);
              curPt = startPt;
              startPt = undefined;
              break;
            }
            case "🏁": {
              // move to previous 🚦 and continue
              do {
                idx = (idx - 1 + iArr.length) % iArr.length;
              } while (resolve(iArr[idx][0]) !== "🚦");
              return nextSegment();
            }
            default:
              throw new Error("Unknown symbol: " + t[0]);
          }
          idx = (idx + 1) % iArr.length;
          return seg;
        }

        // Build a path for a single glyph starting from a given index until 🏁
        function buildGlyphFrom(startIndex) {
          let localIdx = startIndex;
          let localStart = undefined;
          let localCur = undefined;
          const segs = [];
          let guard = 0;
          while (guard++ < iArr.length * 4) {
            const t = iArr[localIdx];
            const e = sArr.slice(4 * t[1], 4 * (t[1] + 1));
            const sym = resolve(t[0]);
            if (sym === "🚦" || sym === "🚗") {
              if (!localStart) localStart = new Vec(e[0], e[1]);
              localCur = new Vec(e[0], e[1]);
              localIdx = (localIdx + 1) % iArr.length;
              continue;
            }
            if (sym === "↔️") {
              const p = new Vec(e[0], e[1]).add(localCur);
              segs.push(new Line(localCur, p));
              localCur = p;
            } else if (sym === "♾️") {
              const c1 = new Vec(e[0], e[1]).add(localCur);
              const p2 = new Vec(e[2], e[3]).add(localCur);
              segs.push(new Quad(localCur, c1, p2));
              localCur = p2;
            } else if (sym === "⏱️") {
              segs.push(new Line(localCur, localStart));
              localCur = localStart;
              // do not reset localStart; some glyphs may have multiple laps
            } else if (sym === "🏁") {
              break;
            } else {
              // Unknown mapping; stop this glyph
              break;
            }
            localIdx = (localIdx + 1) % iArr.length;
          }

          // Normalize to top-left origin and build Path2D
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          for (const seg of segs) {
            for (const p of seg.points()) {
              if (p.x < minX) minX = p.x;
              if (p.y < minY) minY = p.y;
              if (p.x > maxX) maxX = p.x;
              if (p.y > maxY) maxY = p.y;
            }
          }
          const path = new Path2D();
          let first = true;
          for (const seg of segs) {
            const pts = seg.points();
            if (first) {
              path.moveTo(pts[0].x - minX, pts[0].y - minY);
              first = false;
            }
            if (seg instanceof Line) {
              path.lineTo(pts[1].x - minX, pts[1].y - minY);
            } else {
              path.quadraticCurveTo(
                pts[1].x - minX,
                pts[1].y - minY,
                pts[2].x - minX,
                pts[2].y - minY
              );
            }
          }
          return { path, width: maxX - minX, height: maxY - minY };
        }

        // Collect ALL glyph start indices in order (allow repeats)
        const startIndices = [];
        for (let k = 0; k < iArr.length; k++) {
          const [sym] = iArr[k];
          if (resolve(sym) === "🚦") startIndices.push(k);
        }

        // Build glyphs
        let glyphs = startIndices.map((st) => buildGlyphFrom(st));

        // Canvas render with pan/zoom
        const canvas = document.getElementById("cv");
        const ctx = canvas.getContext("2d");

        function resize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          draw();
        }
        window.addEventListener("resize", resize);

        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;

        // Lay out all glyphs left-to-right with spacing, compute bounds
        let laidOut = null;
        let flipX = 1;
        let flipY = -1; // invert vertical by default to counter canvas Y-down vs math Y-up
        let rotDeg = 0;
        let reverseOrder = false;
        let gap = 80;
        function layoutGlyphs() {
          let x = 0;
          let y = 0;
          const list = reverseOrder ? [...glyphs].reverse() : glyphs;
          const paths = [];
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          for (const g of list) {
            const m = new DOMMatrix();
            m.translateSelf(x, y);
            m.rotateSelf(rotDeg);
            m.scaleSelf(flipX, flipY);
            const p = new Path2D();
            p.addPath(g.path, m);
            paths.push(p);
            // transform bounding box corners
            const corners = [
              new DOMPoint(0, 0),
              new DOMPoint(g.width, 0),
              new DOMPoint(g.width, g.height),
              new DOMPoint(0, g.height),
            ].map((pt) => m.transformPoint(pt));
            for (const c of corners) {
              if (c.x < minX) minX = c.x;
              if (c.y < minY) minY = c.y;
              if (c.x > maxX) maxX = c.x;
              if (c.y > maxY) maxY = c.y;
            }
            // advance along untransformed width for spacing
            x += g.width + gap;
          }
          laidOut = { paths, minX, minY, maxX, maxY };
        }

        function fitView() {
          if (!laidOut) layoutGlyphs();
          const w = laidOut.maxX - laidOut.minX;
          const h = laidOut.maxY - laidOut.minY;
          const sx = canvas.width / (w || 1);
          const sy = canvas.height / (h || 1);
          scale = 0.9 * Math.min(sx, sy);
          const cx = (laidOut.minX + laidOut.maxX) / 2;
          const cy = (laidOut.minY + laidOut.maxY) / 2;
          offsetX = canvas.width / 2 - scale * cx;
          offsetY = canvas.height / 2 - scale * cy;
        }

        function draw() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 8 / scale;
          if (!laidOut) layoutGlyphs();
          for (const p of laidOut.paths) ctx.stroke(p);
        }

        // Pan & zoom interactions
        let dragging = false;
        let lastX = 0,
          lastY = 0;
        canvas.addEventListener("mousedown", (e) => {
          dragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
        });
        window.addEventListener("mouseup", () => (dragging = false));
        window.addEventListener("mousemove", (e) => {
          if (!dragging) return;
          offsetX += e.clientX - lastX;
          offsetY += e.clientY - lastY;
          lastX = e.clientX;
          lastY = e.clientY;
          draw();
        });
        canvas.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const delta = Math.sign(e.deltaY);
            const factor = Math.pow(1.1, -delta);
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const xBefore = (mx - offsetX) / scale;
            const yBefore = (my - offsetY) / scale;
            scale *= factor;
            const xAfter = xBefore * scale + offsetX;
            const yAfter = yBefore * scale + offsetY;
            offsetX += mx - xAfter;
            offsetY += my - yAfter;
            draw();
          },
          { passive: false }
        );

        // Keyboard controls to quickly adjust orientation/order
        window.addEventListener("keydown", (e) => {
          if (e.key === "x" || e.key === "X") {
            flipX *= -1;
            laidOut = null;
            fitView();
            draw();
          }
          if (e.key === "y" || e.key === "Y") {
            flipY *= -1;
            laidOut = null;
            fitView();
            draw();
          }
          if (e.key === "[") {
            rotDeg -= 90;
            laidOut = null;
            fitView();
            draw();
          }
          if (e.key === "]") {
            rotDeg += 90;
            laidOut = null;
            fitView();
            draw();
          }
          if (e.key === "o" || e.key === "O") {
            reverseOrder = !reverseOrder;
            laidOut = null;
            fitView();
            draw();
          }
          if (e.key === "+" || e.key === "=") {
            gap += 20;
            laidOut = null;
            fitView();
            draw();
          }
          if (e.key === "-" || e.key === "_") {
            gap = Math.max(0, gap - 20);
            laidOut = null;
            fitView();
            draw();
          }
        });

        resize();
        fitView();
        draw();
      })();
    </script>
  </body>
</html>
